/* seems it's gcm? */
#include <string.h>
#include <stdlib.h>
#include "ghash.h"


void invertBits(u8 *bits, int byteCount)
{
static const u8 invertTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    };

    u8 buf[128];
    int ipos = byteCount - 1;
    for(int i = 0; i < byteCount; i++)
    {
        buf[i] = invertTable[ bits[ipos] ];

        /*u8 ib = bits[ipos];
        u8 ob = 0;
        u8 ibit = 1;
        u8 obit = 0x80;
        for(int j = 0; j < 8; j++)
        {
            if (ib & ibit)
                ob |= obit;
            ibit <<= 1;
            obit >>= 1;
        }

        buf[i] = ob;*/

        ipos--;
    }
    memcpy(bits, buf, byteCount);
}

void REDUCE1_64(u32 *d)
{
    static const u32 xorHi[2] = {0, 0xD8000000};

    u32 hi = d[0];
    u32 lo = d[1];

    u32 nlo = BSWAP4(lo);
    u32 nhi = BSWAP4(hi);

    const u8 lobit = nlo & 1;

    lo = (nlo >> 1) | ((nhi & 1) << 31);
    hi = (nhi >> 1) ^ xorHi[lobit];

    d[0] = BSWAP4(hi);
    d[1] = BSWAP4(lo);
}

void ghash_table64(u32 *in, u32 *table)
{
    static const unsigned short rem[256] = {
    0x0000, 0xb001, 0x6003, 0xd002, 0xc006, 0x7007, 0xa005, 0x1004, 0x800d, 0x300c, 0xe00e, 0x500f, 0x400b, 0xf00a, 0x2008, 0x9009,
    0x001b, 0xb01a, 0x6018, 0xd019, 0xc01d, 0x701c, 0xa01e, 0x101f, 0x8016, 0x3017, 0xe015, 0x5014, 0x4010, 0xf011, 0x2013, 0x9012,
    0x0036, 0xb037, 0x6035, 0xd034, 0xc030, 0x7031, 0xa033, 0x1032, 0x803b, 0x303a, 0xe038, 0x5039, 0x403d, 0xf03c, 0x203e, 0x903f,
    0x002d, 0xb02c, 0x602e, 0xd02f, 0xc02b, 0x702a, 0xa028, 0x1029, 0x8020, 0x3021, 0xe023, 0x5022, 0x4026, 0xf027, 0x2025, 0x9024,
    0x006c, 0xb06d, 0x606f, 0xd06e, 0xc06a, 0x706b, 0xa069, 0x1068, 0x8061, 0x3060, 0xe062, 0x5063, 0x4067, 0xf066, 0x2064, 0x9065,
    0x0077, 0xb076, 0x6074, 0xd075, 0xc071, 0x7070, 0xa072, 0x1073, 0x807a, 0x307b, 0xe079, 0x5078, 0x407c, 0xf07d, 0x207f, 0x907e,
    0x005a, 0xb05b, 0x6059, 0xd058, 0xc05c, 0x705d, 0xa05f, 0x105e, 0x8057, 0x3056, 0xe054, 0x5055, 0x4051, 0xf050, 0x2052, 0x9053,
    0x0041, 0xb040, 0x6042, 0xd043, 0xc047, 0x7046, 0xa044, 0x1045, 0x804c, 0x304d, 0xe04f, 0x504e, 0x404a, 0xf04b, 0x2049, 0x9048,
    0x00d8, 0xb0d9, 0x60db, 0xd0da, 0xc0de, 0x70df, 0xa0dd, 0x10dc, 0x80d5, 0x30d4, 0xe0d6, 0x50d7, 0x40d3, 0xf0d2, 0x20d0, 0x90d1,
    0x00c3, 0xb0c2, 0x60c0, 0xd0c1, 0xc0c5, 0x70c4, 0xa0c6, 0x10c7, 0x80ce, 0x30cf, 0xe0cd, 0x50cc, 0x40c8, 0xf0c9, 0x20cb, 0x90ca,
    0x00ee, 0xb0ef, 0x60ed, 0xd0ec, 0xc0e8, 0x70e9, 0xa0eb, 0x10ea, 0x80e3, 0x30e2, 0xe0e0, 0x50e1, 0x40e5, 0xf0e4, 0x20e6, 0x90e7,
    0x00f5, 0xb0f4, 0x60f6, 0xd0f7, 0xc0f3, 0x70f2, 0xa0f0, 0x10f1, 0x80f8, 0x30f9, 0xe0fb, 0x50fa, 0x40fe, 0xf0ff, 0x20fd, 0x90fc,
    0x00b4, 0xb0b5, 0x60b7, 0xd0b6, 0xc0b2, 0x70b3, 0xa0b1, 0x10b0, 0x80b9, 0x30b8, 0xe0ba, 0x50bb, 0x40bf, 0xf0be, 0x20bc, 0x90bd,
    0x00af, 0xb0ae, 0x60ac, 0xd0ad, 0xc0a9, 0x70a8, 0xa0aa, 0x10ab, 0x80a2, 0x30a3, 0xe0a1, 0x50a0, 0x40a4, 0xf0a5, 0x20a7, 0x90a6,
    0x0082, 0xb083, 0x6081, 0xd080, 0xc084, 0x7085, 0xa087, 0x1086, 0x808f, 0x308e, 0xe08c, 0x508d, 0x4089, 0xf088, 0x208a, 0x908b,
    0x0099, 0xb098, 0x609a, 0xd09b, 0xc09f, 0x709e, 0xa09c, 0x109d, 0x8094, 0x3095, 0xe097, 0x5096, 0x4092, 0xf093, 0x2091, 0x9090 };


    memset(table, 0, sizeof(u32) * 16 * 16 * 2);

    u32 pair[2];

    int idx = 0;
    for(int i = 0; i < 16; i++)
    {
        if (i == 0)
        {
            table[48 * 2] = in[0];
            table[48 * 2 + 1] = in[1];

            for(u8 m = 4; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ ((m * 2) + 16) * 4 ], sizeof(pair));
                REDUCE1_64(pair);
                memcpy(&table[ (m + 16) * 4 ], pair, sizeof(pair));
            }

            memcpy(pair, &table[34 * 2], sizeof(pair));
            REDUCE1_64(pair);
            memcpy(&table[16 * 2], pair, sizeof(pair));

            for(u8 m = 4; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ (m * 2) * 4 ], sizeof(pair));
                REDUCE1_64(pair);
                memcpy(&table[ m * 4 ], pair, sizeof(pair));
            }
        }
        else if (i > 1)
        {
            for(u8 m = 8; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ ((m - 32) + idx) * 4 ], sizeof(pair));
                table[ (m + idx) * 4 + 1 ] = (pair[1] << 8) | (pair[0] >> 24);
                table[ (m + idx) * 4 ] = rem[pair[1] >> 24] ^ (pair[0] << 8);
            }
        }

        for(int k = 2; k < 16; k <<= 1)
        {
            u32 *p = table + (k + idx) * 4;
            if (k > 1)
            {
                for(int j = 0; j < k - 1; j++)
                {
                    u32 *pv = table + i * 32 * 2 + 4 + j * 4;
                    u32 *po = table + i * 32 * 2 + (k + 1) * 4 + j * 4;
                    po[0] = pv[0] ^ p[0];
                    po[1] = pv[1] ^ p[1];
                    po[2] = pv[2] ^ p[2];
                    po[3] = pv[3] ^ p[3];
                }
            }
        }
        idx += 16;
    }
}

void ghash_init64(u8 *in, GHash *table)
{
    u32 *tmp = (u32 *)malloc(16 * 16 * 2 * 4 * 2/*padding to 16?*/);
    u8 dat[8];
    memcpy(dat, in, 8);
    invertBits(dat, 8);
    ghash_table64((u32 *)dat, tmp);

    u32 *p = tmp + ((16 * 2 * 2) * 15);
    for(int i = 0; i < 16; i ++)
    {
        for(int j = 0; j < 16; j++)
        {
            u32 *pv = p + j * 2 * 2;
            int idx = BITSWAP4(j);
            table->table64[i][idx][0] = pv[0];
            table->table64[i][idx][1] = pv[1];

            invertBits((u8 *)&table->table64[i][idx][0], 8);
        }

        p -= 16 * 2 * 2;
    }

    free(tmp);
}


void REDUCE1_128(u64 *d)
{
    static const u64 xorHi[2] = {0, 0xe100000000000000};

    u64 hi = d[0];
    u64 lo = d[1];

    u64 nlo = BSWAP8(lo);
    u64 nhi = BSWAP8(hi);

    const u8 lobit = nlo & 1;

    lo = (nlo >> 1) | ((nhi & 1) << 63);
    hi = (nhi >> 1) ^ xorHi[lobit];

    d[0] = BSWAP8(hi);
    d[1] = BSWAP8(lo);
}

void ghash_table128(u64 *in, u64 *table)
{
    static const unsigned short rem[256] = {
    0x0000, 0xc201, 0x8403, 0x4602, 0x0807, 0xca06, 0x8c04, 0x4e05, 0x100e, 0xd20f, 0x940d, 0x560c, 0x1809, 0xda08, 0x9c0a, 0x5e0b,
    0x201c, 0xe21d, 0xa41f, 0x661e, 0x281b, 0xea1a, 0xac18, 0x6e19, 0x3012, 0xf213, 0xb411, 0x7610, 0x3815, 0xfa14, 0xbc16, 0x7e17,
    0x4038, 0x8239, 0xc43b, 0x063a, 0x483f, 0x8a3e, 0xcc3c, 0x0e3d, 0x5036, 0x9237, 0xd435, 0x1634, 0x5831, 0x9a30, 0xdc32, 0x1e33,
    0x6024, 0xa225, 0xe427, 0x2626, 0x6823, 0xaa22, 0xec20, 0x2e21, 0x702a, 0xb22b, 0xf429, 0x3628, 0x782d, 0xba2c, 0xfc2e, 0x3e2f,
    0x8070, 0x4271, 0x0473, 0xc672, 0x8877, 0x4a76, 0x0c74, 0xce75, 0x907e, 0x527f, 0x147d, 0xd67c, 0x9879, 0x5a78, 0x1c7a, 0xde7b,
    0xa06c, 0x626d, 0x246f, 0xe66e, 0xa86b, 0x6a6a, 0x2c68, 0xee69, 0xb062, 0x7263, 0x3461, 0xf660, 0xb865, 0x7a64, 0x3c66, 0xfe67,
    0xc048, 0x0249, 0x444b, 0x864a, 0xc84f, 0x0a4e, 0x4c4c, 0x8e4d, 0xd046, 0x1247, 0x5445, 0x9644, 0xd841, 0x1a40, 0x5c42, 0x9e43,
    0xe054, 0x2255, 0x6457, 0xa656, 0xe853, 0x2a52, 0x6c50, 0xae51, 0xf05a, 0x325b, 0x7459, 0xb658, 0xf85d, 0x3a5c, 0x7c5e, 0xbe5f,
    0x00e1, 0xc2e0, 0x84e2, 0x46e3, 0x08e6, 0xcae7, 0x8ce5, 0x4ee4, 0x10ef, 0xd2ee, 0x94ec, 0x56ed, 0x18e8, 0xdae9, 0x9ceb, 0x5eea,
    0x20fd, 0xe2fc, 0xa4fe, 0x66ff, 0x28fa, 0xeafb, 0xacf9, 0x6ef8, 0x30f3, 0xf2f2, 0xb4f0, 0x76f1, 0x38f4, 0xfaf5, 0xbcf7, 0x7ef6,
    0x40d9, 0x82d8, 0xc4da, 0x06db, 0x48de, 0x8adf, 0xccdd, 0x0edc, 0x50d7, 0x92d6, 0xd4d4, 0x16d5, 0x58d0, 0x9ad1, 0xdcd3, 0x1ed2,
    0x60c5, 0xa2c4, 0xe4c6, 0x26c7, 0x68c2, 0xaac3, 0xecc1, 0x2ec0, 0x70cb, 0xb2ca, 0xf4c8, 0x36c9, 0x78cc, 0xbacd, 0xfccf, 0x3ece,
    0x8091, 0x4290, 0x0492, 0xc693, 0x8896, 0x4a97, 0x0c95, 0xce94, 0x909f, 0x529e, 0x149c, 0xd69d, 0x9898, 0x5a99, 0x1c9b, 0xde9a,
    0xa08d, 0x628c, 0x248e, 0xe68f, 0xa88a, 0x6a8b, 0x2c89, 0xee88, 0xb083, 0x7282, 0x3480, 0xf681, 0xb884, 0x7a85, 0x3c87, 0xfe86,
    0xc0a9, 0x02a8, 0x44aa, 0x86ab, 0xc8ae, 0x0aaf, 0x4cad, 0x8eac, 0xd0a7, 0x12a6, 0x54a4, 0x96a5, 0xd8a0, 0x1aa1, 0x5ca3, 0x9ea2,
    0xe0b5, 0x22b4, 0x64b6, 0xa6b7, 0xe8b2, 0x2ab3, 0x6cb1, 0xaeb0, 0xf0bb, 0x32ba, 0x74b8, 0xb6b9, 0xf8bc, 0x3abd, 0x7cbf, 0xbebe };


    memset(table, 0, sizeof(u64) * 16 * 16 * 2);

    u64 pair[2];

    int idx = 0;
    for(int i = 0; i < 32; i++)
    {
        if (i == 0)
        {
            table[48] = in[0];
            table[49] = in[1];

            for(u8 m = 4; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ ((m * 2) + 16) * 2 ], sizeof(pair));
                REDUCE1_128(pair);
                memcpy(&table[ (m + 16) * 2 ], pair, sizeof(pair));
            }

            memcpy(pair, &table[34], sizeof(pair));
            REDUCE1_128(pair);
            memcpy(&table[16], pair, sizeof(pair));

            for(u8 m = 4; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ (m * 2) * 2 ], sizeof(pair));
                REDUCE1_128(pair);
                memcpy(&table[ m * 2 ], pair, sizeof(pair));
            }
        }
        else if (i > 1)
        {
            for(u8 m = 8; m != 0; m >>= 1)
            {
                memcpy(pair, &table[ ((m - 32) + idx) * 2 ], sizeof(pair));
                table[ (m + idx) * 2 + 1 ] = (pair[1] << 8) | (pair[0] >> 56);
                table[ (m + idx) * 2 ] = rem[pair[1] >> 56] ^ (pair[0] << 8);
            }
        }

        for(int k = 2; k < 16; k <<= 1)
        {
            u64 *p = table + (k + idx) * 2;
            if (k > 1)
            {
                for(int j = 0; j < k - 1; j++)
                {
                    u64 *pv = table + i * 32 + 2 + j * 2;
                    u64 *po = table + i * 32 + (k + 1) * 2 + j * 2;
                    po[0] = pv[0] ^ p[0];
                    po[1] = pv[1] ^ p[1];
                }
            }
        }
        idx += 16;
    }
}


void ghash_init128(u8 *in, GHash *table)
{
    u64 *tmp = (u64 *)malloc(32 * 16 * 2 * 8/*sizeof(u64)*/);
    u8 dat[16];
    memcpy(dat, in, 16);
    invertBits(dat, 16);
    ghash_table128((u64 *)dat, tmp);

    u64 *p = tmp + ((16 * 2) * 15);
    for(int i = 0; i < 16; i ++)
    {
        for(int j = 0; j < 16; j++)
        {
            u64 *pv = p + j * 2;
            int idx = BITSWAP4(j);
            table->table128[i][idx][0] = pv[0];
            table->table128[i][idx][1] = pv[1];

            invertBits((u8 *)&table->table128[i][idx][0], 16);
        }

        p -= 16 * 2;
    }

    free(tmp);
}

void ghash128(u8 *in, u64 *out, GHash *table)
{
    u64 lo = 0;
    u64 hi = 0;

    if (in[0] != 0 || in[1] != 0)
    {
        lo ^= table->table128[0][ in[0] & 0xf ][0];
        hi ^= table->table128[0][ in[0] & 0xf ][1];
        lo ^= table->table128[1][ in[0] >> 4 ][0];
        hi ^= table->table128[1][ in[0] >> 4 ][1];
        lo ^= table->table128[2][ in[1] & 0xf ][0];
        hi ^= table->table128[2][ in[1] & 0xf ][1];
        lo ^= table->table128[3][ in[1] >> 4 ][0];
        hi ^= table->table128[3][ in[1] >> 4 ][1];
    }
    if (in[2] != 0)
    {
        lo ^= table->table128[4][ in[2] & 0xf ][0];
        hi ^= table->table128[4][ in[2] & 0xf ][1];
        lo ^= table->table128[5][ in[2] >> 4 ][0];
        hi ^= table->table128[5][ in[2] >> 4 ][1];
    }

    for (int i = 3; i < 8; i++)
    {
        lo ^= table->table128[i * 2][ in[i] & 0xf ][0];
        hi ^= table->table128[i * 2][ in[i] & 0xf ][1];
        lo ^= table->table128[i * 2 + 1][ in[i] >> 4 ][0];
        hi ^= table->table128[i * 2 + 1][ in[i] >> 4 ][1];
    }

    out[0] = lo;
    out[1] = hi;
}
